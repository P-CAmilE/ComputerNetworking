# 第六章练习题

## P6

**a.** 当D的值为1001010101，G值为10011，G有5位，所以R有4位，使用左移四位后的D除以G（采用模2运算）：

$$10010101010000 \div 10011$$

我们得到商为1000110000，余数0000，所以R=0000。

**b.** 当D的值为0101101010，G值为10011，G有5位，所以R有4位，使用左移四位后的D除以G（采用模2运算）：

$$01011010100000 \div 10011$$

我们得到商为0101010101，余数1111，所以R=1111。

**c.** 当D的值为1010100000，G值为10011，G有5位，所以R有4位，使用左移四位后的D除以G（采用模2运算）：

$$10101000000000 \div 10011$$

我们得到商为1011010111，余数1001，所以R=1001。


## P7

**a.** 在我们考虑到数据D中出现任单比特错误的时候，假设从低位到高位中第$i(1 \leq i \leq d)$位出现比特错误，这将导致在接收方计算D移位后的数据时，造成实际数据为：

$$D_{实际}\cdot2^{r} = D\cdot2^{r} + 2^{i+r-1}$$

且等式$D\cdot2^{r} XOR\;R = nG$成立，所以要使$D_{实际}\cdot2^{r} XOR\;R = nG$成立，当且仅当$2^{i+r-1}$被G整除。在G为1001的情况下，即G包含多于一个1的情况下，是始终无法整除的，所以它能够检验D中任何单比特差错。

**b.** 上述G能够检测任何奇数比特差错。因为G=1001能够被11整除，而奇数比特差错造成出现奇数个1穿插着0形成的序列，这些序列都不可能被11整除，所以都不能被G整除。这就导致出现奇数比特差错后，$D\cdot2^{r} XOR\;R $除以G的余数不为0，所以能检测出错误。

